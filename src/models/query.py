"""Data models for queries and responses."""

from datetime import datetime
from typing import List, Optional
from pydantic import BaseModel, Field
from .document import RetrievedChunk


class Question(BaseModel):
    """Represents a natural language query from the user about book content."""

    id: str = Field(description="Unique identifier for the question")
    content: str = Field(description="The natural language question text")
    timestamp: datetime = Field(default_factory=datetime.now, description="When the question was asked")
    user_id: Optional[str] = Field(default=None, description="Identifier for the user (if applicable)")

    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }

    @classmethod
    def create(cls, content: str, user_id: Optional[str] = None) -> "Question":
        """Create a new Question instance."""
        import uuid
        return cls(
            id=str(uuid.uuid4()),
            content=content,
            user_id=user_id
        )

    def validate(self) -> bool:
        """Validate the question content."""
        if not self.content or not self.content.strip():
            raise ValueError("Question content cannot be empty")

        if len(self.content) < 5:
            raise ValueError("Question content must be at least 5 characters")

        if len(self.content) > 1000:
            raise ValueError("Question content cannot exceed 1000 characters")

        return True


class QueryEmbedding(BaseModel):
    """Represents the vector embedding of a question for semantic search."""

    question_id: str = Field(description="Reference to the original question")
    embedding: List[float] = Field(description="The embedding vector")
    model: str = Field(description="The model used to generate the embedding")
    timestamp: datetime = Field(default_factory=datetime.now, description="When the embedding was generated")

    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }

    @classmethod
    def create(cls, question_id: str, embedding: List[float], model: str) -> "QueryEmbedding":
        """Create a new QueryEmbedding instance."""
        return cls(
            question_id=question_id,
            embedding=embedding,
            model=model
        )

    def validate(self) -> bool:
        """Validate the query embedding."""
        if not self.question_id:
            raise ValueError("Question ID cannot be empty")

        if not self.embedding or len(self.embedding) == 0:
            raise ValueError("Embedding vector cannot be empty")

        if not self.model:
            raise ValueError("Model name cannot be empty")

        return True


class Answer(BaseModel):
    """Represents the synthesized response generated by the agent based on retrieved content."""

    id: str = Field(description="Unique identifier for the answer")
    question_id: str = Field(description="Reference to the original question")
    content: str = Field(description="The answer text synthesized from retrieved content")
    source_chunks: List[RetrievedChunk] = Field(description="List of chunks used to generate the answer")
    confidence: float = Field(description="Confidence score of the answer")
    timestamp: datetime = Field(default_factory=datetime.now, description="When the answer was generated")
    generated_by: str = Field(description="The model used to generate the answer")

    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }

    @classmethod
    def create(
        cls,
        question_id: str,
        content: str,
        source_chunks: List[RetrievedChunk],
        confidence: float,
        generated_by: str
    ) -> "Answer":
        """Create a new Answer instance."""
        import uuid
        return cls(
            id=str(uuid.uuid4()),
            question_id=question_id,
            content=content,
            source_chunks=source_chunks,
            confidence=confidence,
            generated_by=generated_by
        )

    def validate(self) -> bool:
        """Validate the answer."""
        if not self.content or not self.content.strip():
            raise ValueError("Answer content cannot be empty")

        if not self.source_chunks:
            raise ValueError("Answer must reference at least one retrieved chunk")

        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError("Confidence score must be between 0.0 and 1.0")

        if not self.generated_by:
            raise ValueError("Generated by model cannot be empty")

        return True

    def has_sufficient_sources(self) -> bool:
        """Check if the answer has sufficient source chunks."""
        return len(self.source_chunks) > 0

    def get_source_urls(self) -> List[str]:
        """Get unique source URLs from the source chunks."""
        urls = set()
        for chunk in self.source_chunks:
            if chunk.source_url:
                urls.add(chunk.source_url)
        return list(urls)